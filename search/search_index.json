{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GeoZarr examples","text":""},{"location":"#overview","title":"Overview","text":"<p>GeoZarr examples provides examples and documentation for working with GeoZarr-compliant Zarr stores, using the modular Zarr conventions:</p> <ul> <li>spatial: - Spatial coordinate and transformation information</li> <li>proj: - Coordinate Reference System (CRS) information</li> <li>multiscales - Multiscale pyramid layout</li> </ul> <p>These examples leverage the Python library  geozarr-toolkit for creating and validating GeoZarr-compliant Zarr stores.</p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Demonstrate how to write GeoZarr compliant data.<ul> <li>Provide a demonstration of writing CRS information.</li> <li>Provide a demonstration of writing bounding box information.</li> <li>Provide a demonstration of writing multiscale data.</li> <li>Provide a demonstration of writing multi-scale data conforming to a specific well-known tile matrix set (TMS)</li> <li>Provide a demonstration of storing raw data in NetCDF and overviews in native Zarr, with a virtual GeoZarr compliant entrypoint.</li> </ul> </li> <li>Demonstrate how to read GeoZarr compliant data.<ul> <li>Provide a demonstration of reading in GeoZarr data with raw data in \"native\" zarr.</li> <li>Provide a demonstration of reading in GeoZarr data with raw data and overviews in \"native\" zarr.</li> <li>Provide a demonstration of reading in GeoZarr data with raw data in archival formats and overviews in \"native\" zarr via a single virtual GeoZarr compliant entrypoint.</li> </ul> </li> <li>Demonstrate how to work with GeoZarr data in Xarray using flexible coordinates and the xproj extension.</li> <li>Demonstrate how to work with GeoZarr data in OpenLayers.</li> <li>Demonstrate how to work with GeoZarr data in GDAL.</li> </ul>"},{"location":"#feedback-cadence","title":"Feedback cadence","text":"<p>We will provide progress and solicit community feedback during the monthly OGC SWG Meetings. Find out more at geozarr.org.</p> <p>See the GeoZarr FAQ for common questions about GeoZarr.</p>"},{"location":"#referencesacknowledgements","title":"References/Acknowledgements","text":""},{"location":"#specifications-and-standards","title":"Specifications and Standards","text":"<ul> <li>GeoZarr spec CC BY 4.0</li> <li>CF Conventions - Climate and Forecast metadata conventions</li> <li>STAC Extensions Template - Convention documentation structure</li> <li>EOPF-Explorer Data Model - Base implementation for geo-proj and spatial conventions</li> <li>Zarr Extensions PR #21 - Original draft of conventions</li> </ul>"},{"location":"#code-attribution","title":"Code Attribution","text":"<p>The Python convention models (<code>Spatial</code>, <code>Proj</code>, <code>Multiscales</code>, etc.) in this library follow patterns established in:</p> <ul> <li>eopf-geozarr - Pydantic models for GeoZarr conventions, part of the EOPF (Earth Observation Processing Framework) ecosystem</li> </ul>"},{"location":"#software-libraries","title":"Software Libraries","text":"<p>Examples in this repository use the following open-source libraries:</p> <ul> <li>Geozarr-toolkit - Tools for creating and validating GeoZarr data (MIT License)</li> <li>Zarr - Chunked array storage format (MIT License)</li> <li>xarray - N-dimensional labeled arrays (Apache 2.0)</li> <li>rioxarray - Rasterio xarray extension (Apache 2.0)</li> <li>cf-xarray - CF conventions for xarray (Apache 2.0)</li> <li>Rasterio - Geospatial raster I/O (BSD 3-Clause)</li> <li>pyproj - Cartographic projections (MIT License)</li> <li>Affine - Affine transformation library (BSD 3-Clause)</li> <li>morecantile - Tile Matrix Set utilities (MIT License)</li> <li>rio-tiler - Rasterio plugin for COG tiles (MIT License)</li> <li>earthaccess - NASA Earthdata access (MIT License)</li> </ul>"},{"location":"#tools-and-validators","title":"Tools and Validators","text":"<ul> <li>https://inspect.geozarr.org/ - Browser based inspector and validator</li> <li>AJV - JSON Schema validator used in convention tests (MIT License)</li> </ul>"},{"location":"#data","title":"Data","text":"<p>Example notebooks use data from:</p> <ul> <li>NASA JPL MUR-SST - Multi-scale Ultra-high Resolution Sea Surface Temperature</li> <li>Copernicus Sentinel-2 via Earth Search</li> </ul>"},{"location":"#prior-art","title":"Prior art","text":"<ul> <li>GeoZarr validator by @briannapagan CC BY 4.0 - Test validator used during the development of the GeoZarr spec. Not applicable to the proposed release candidate (i.e., outdated).</li> </ul>"},{"location":"#license","title":"License","text":"<p>Content in this repository is licensed under the MIT License.</p>"},{"location":"examples/cog-to-zarr/","title":"Converting a Cloud-Optimized GeoTIFF to Zarr","text":"In\u00a0[1]: Copied! <pre>import json\n\nfrom geozarr_toolkit import (\n    MultiscalesConventionMetadata,\n    ProjConventionMetadata,\n    SpatialConventionMetadata,\n    create_multiscales_layout,\n    create_proj_attrs,\n    create_spatial_attrs,\n    create_zarr_conventions,\n)\n</pre> import json  from geozarr_toolkit import (     MultiscalesConventionMetadata,     ProjConventionMetadata,     SpatialConventionMetadata,     create_multiscales_layout,     create_proj_attrs,     create_spatial_attrs,     create_zarr_conventions, ) In\u00a0[2]: Copied! <pre># Set to True to write to S3, False to use a local store\nUSE_S3 = False\n</pre> # Set to True to write to S3, False to use a local store USE_S3 = False In\u00a0[3]: Copied! <pre>from async_geotiff import GeoTIFF\nfrom obstore.store import S3Store\n\nstore = S3Store(\"sentinel-cogs\", region=\"us-west-2\", skip_signature=True)\npath = \"sentinel-s2-l2a-cogs/12/S/UF/2022/6/S2B_12SUF_20220609_0_L2A/TCI.tif\"\n\ngeotiff = await GeoTIFF.open(path, store=store)\n\nprint(f\"CRS:       {geotiff.crs}\")\nprint(f\"Transform: {geotiff.transform}\")\nprint(f\"Shape:     {geotiff.shape}\")\nprint(f\"Bounds:    {geotiff.bounds}\")\nprint(f\"Bands:     {geotiff.count}\")\nprint(f\"Dtype:     {geotiff.dtype}\")\n</pre> from async_geotiff import GeoTIFF from obstore.store import S3Store  store = S3Store(\"sentinel-cogs\", region=\"us-west-2\", skip_signature=True) path = \"sentinel-s2-l2a-cogs/12/S/UF/2022/6/S2B_12SUF_20220609_0_L2A/TCI.tif\"  geotiff = await GeoTIFF.open(path, store=store)  print(f\"CRS:       {geotiff.crs}\") print(f\"Transform: {geotiff.transform}\") print(f\"Shape:     {geotiff.shape}\") print(f\"Bounds:    {geotiff.bounds}\") print(f\"Bands:     {geotiff.count}\") print(f\"Dtype:     {geotiff.dtype}\") <pre>CRS:       EPSG:32612\nTransform: | 10.00, 0.00, 300000.00|\n| 0.00,-10.00, 4100040.00|\n| 0.00, 0.00, 1.00|\nShape:     (10980, 10980)\nBounds:    (300000.0, 3990240.0, 409800.0, 4100040.0)\nBands:     3\nDtype:     uint8\n</pre> In\u00a0[4]: Copied! <pre># Build proj: and spatial: attributes from the GeoTIFF's properties\nt = geotiff.transform\n\ngeozarr_attrs = create_proj_attrs(code=f\"EPSG:{geotiff.crs.to_epsg()}\")\ngeozarr_attrs.update(\n    create_spatial_attrs(\n        dimensions=[\"Y\", \"X\"],\n        bbox=list(geotiff.bounds),\n    )\n)\n\n# Build multiscales layout from the COG's overviews\n# The base (full-resolution) image is level 0; each overview is a coarser level.\nbase_res = t.a  # pixel width of the base level\nlevels = [\n    {\"asset\": \"0\", \"transform\": {\"scale\": [1.0, 1.0], \"translation\": [0.0, 0.0]}},\n]\nfor i, overview in enumerate(geotiff.overviews):\n    ov_res = overview.transform.a\n    scale_factor = ov_res / base_res\n    levels.append(\n        {\n            \"asset\": str(i + 1),\n            \"derived_from\": \"0\",\n            \"transform\": {\n                \"scale\": [scale_factor, scale_factor],\n                \"translation\": [0.0, 0.0],\n            },\n        }\n    )\n\ngeozarr_attrs.update(create_multiscales_layout(levels))\ngeozarr_attrs[\"zarr_conventions\"] = create_zarr_conventions(\n    MultiscalesConventionMetadata(),\n    ProjConventionMetadata(),\n    SpatialConventionMetadata(),\n)\n\nprint(f\"Base resolution: {base_res} m\")\nprint(f\"Overview levels: {len(geotiff.overviews)}\")\nfor i, overview in enumerate(geotiff.overviews):\n    print(\n        f\"  Overview {i+1}: {overview.width}x{overview.height} px, {overview.transform.a:.1f} m/px\"\n    )\nprint()\nprint(json.dumps(geozarr_attrs, indent=2))\n</pre> # Build proj: and spatial: attributes from the GeoTIFF's properties t = geotiff.transform  geozarr_attrs = create_proj_attrs(code=f\"EPSG:{geotiff.crs.to_epsg()}\") geozarr_attrs.update(     create_spatial_attrs(         dimensions=[\"Y\", \"X\"],         bbox=list(geotiff.bounds),     ) )  # Build multiscales layout from the COG's overviews # The base (full-resolution) image is level 0; each overview is a coarser level. base_res = t.a  # pixel width of the base level levels = [     {\"asset\": \"0\", \"transform\": {\"scale\": [1.0, 1.0], \"translation\": [0.0, 0.0]}}, ] for i, overview in enumerate(geotiff.overviews):     ov_res = overview.transform.a     scale_factor = ov_res / base_res     levels.append(         {             \"asset\": str(i + 1),             \"derived_from\": \"0\",             \"transform\": {                 \"scale\": [scale_factor, scale_factor],                 \"translation\": [0.0, 0.0],             },         }     )  geozarr_attrs.update(create_multiscales_layout(levels)) geozarr_attrs[\"zarr_conventions\"] = create_zarr_conventions(     MultiscalesConventionMetadata(),     ProjConventionMetadata(),     SpatialConventionMetadata(), )  print(f\"Base resolution: {base_res} m\") print(f\"Overview levels: {len(geotiff.overviews)}\") for i, overview in enumerate(geotiff.overviews):     print(         f\"  Overview {i+1}: {overview.width}x{overview.height} px, {overview.transform.a:.1f} m/px\"     ) print() print(json.dumps(geozarr_attrs, indent=2)) <pre>Base resolution: 10.0 m\nOverview levels: 4\n  Overview 1: 5490x5490 px, 20.0 m/px\n  Overview 2: 2745x2745 px, 40.0 m/px\n  Overview 3: 1373x1373 px, 80.0 m/px\n  Overview 4: 687x687 px, 159.8 m/px\n\n{\n  \"proj:code\": \"EPSG:32612\",\n  \"spatial:dimensions\": [\n    \"Y\",\n    \"X\"\n  ],\n  \"spatial:bbox\": [\n    300000.0,\n    3990240.0,\n    409800.0,\n    4100040.0\n  ],\n  \"spatial:transform_type\": \"affine\",\n  \"spatial:registration\": \"pixel\",\n  \"multiscales\": {\n    \"layout\": [\n      {\n        \"asset\": \"0\",\n        \"transform\": {\n          \"scale\": [\n            1.0,\n            1.0\n          ],\n          \"translation\": [\n            0.0,\n            0.0\n          ]\n        }\n      },\n      {\n        \"asset\": \"1\",\n        \"derived_from\": \"0\",\n        \"transform\": {\n          \"scale\": [\n            2.0,\n            2.0\n          ],\n          \"translation\": [\n            0.0,\n            0.0\n          ]\n        }\n      },\n      {\n        \"asset\": \"2\",\n        \"derived_from\": \"0\",\n        \"transform\": {\n          \"scale\": [\n            4.0,\n            4.0\n          ],\n          \"translation\": [\n            0.0,\n            0.0\n          ]\n        }\n      },\n      {\n        \"asset\": \"3\",\n        \"derived_from\": \"0\",\n        \"transform\": {\n          \"scale\": [\n            7.997086671522214,\n            7.997086671522214\n          ],\n          \"translation\": [\n            0.0,\n            0.0\n          ]\n        }\n      },\n      {\n        \"asset\": \"4\",\n        \"derived_from\": \"0\",\n        \"transform\": {\n          \"scale\": [\n            15.982532751091702,\n            15.982532751091702\n          ],\n          \"translation\": [\n            0.0,\n            0.0\n          ]\n        }\n      }\n    ]\n  },\n  \"zarr_conventions\": [\n    {\n      \"uuid\": \"d35379db-88df-4056-af3a-620245f8e347\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-conventions/multiscales/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-conventions/multiscales/blob/v1/README.md\",\n      \"name\": \"multiscales\",\n      \"description\": \"Multiscale layout of zarr datasets\"\n    },\n    {\n      \"uuid\": \"f17cb550-5864-4468-aeb7-f3180cfb622f\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-experimental/geo-proj/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-experimental/geo-proj/blob/v1/README.md\",\n      \"name\": \"proj:\",\n      \"description\": \"Coordinate reference system information for geospatial data\"\n    },\n    {\n      \"uuid\": \"689b58e2-cf7b-45e0-9fff-9cfc0883d6b4\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-conventions/spatial/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-conventions/spatial/blob/v1/README.md\",\n      \"name\": \"spatial:\",\n      \"description\": \"Spatial coordinate and transformation information\"\n    }\n  ]\n}\n</pre> In\u00a0[5]: Copied! <pre>import zarr\nfrom zarr.storage import LocalStore, ObjectStore\n\nbucket = \"us-west-2.opendata.source.coop\"\nprefix = \"pangeo/geozarr-examples/TCI.zarr\"\nlocal_path = \"data/TCI.zarr\"\n\nif USE_S3:\n    output_store = S3Store(bucket, prefix=prefix, region=\"us-west-2\")\n    zarr_store = ObjectStore(output_store)\nelse:\n    zarr_store = LocalStore(local_path)\n\nroot: zarr.Group = zarr.open_group(zarr_store, mode=\"w\", zarr_format=3)\n\n# Set convention attributes on the group\nroot.attrs.update(geozarr_attrs)\n\n# Write the full-resolution image as level \"0\"\nbase_array = await geotiff.read()\nroot.create_array(\"0\", data=base_array.data, chunks=(3, 512, 512))\nprint(f\"Level 0 (base): shape={base_array.data.shape}, dtype={base_array.data.dtype}\")\n\n# Write each overview as a separate level\nfor i, overview in enumerate(geotiff.overviews):\n    ov_array = await overview.read()\n    root.create_array(str(i + 1), data=ov_array.data, chunks=(3, 512, 512))\n    print(f\"Level {i+1} (overview): shape={ov_array.data.shape}\")\n\nlocation = f\"s3://{bucket}/{prefix}\" if USE_S3 else local_path\nprint(f\"\\nWrote Zarr V3 store to {location}\")\n</pre> import zarr from zarr.storage import LocalStore, ObjectStore  bucket = \"us-west-2.opendata.source.coop\" prefix = \"pangeo/geozarr-examples/TCI.zarr\" local_path = \"data/TCI.zarr\"  if USE_S3:     output_store = S3Store(bucket, prefix=prefix, region=\"us-west-2\")     zarr_store = ObjectStore(output_store) else:     zarr_store = LocalStore(local_path)  root: zarr.Group = zarr.open_group(zarr_store, mode=\"w\", zarr_format=3)  # Set convention attributes on the group root.attrs.update(geozarr_attrs)  # Write the full-resolution image as level \"0\" base_array = await geotiff.read() root.create_array(\"0\", data=base_array.data, chunks=(3, 512, 512)) print(f\"Level 0 (base): shape={base_array.data.shape}, dtype={base_array.data.dtype}\")  # Write each overview as a separate level for i, overview in enumerate(geotiff.overviews):     ov_array = await overview.read()     root.create_array(str(i + 1), data=ov_array.data, chunks=(3, 512, 512))     print(f\"Level {i+1} (overview): shape={ov_array.data.shape}\")  location = f\"s3://{bucket}/{prefix}\" if USE_S3 else local_path print(f\"\\nWrote Zarr V3 store to {location}\") <pre>Level 0 (base): shape=(3, 10980, 10980), dtype=uint8\nLevel 1 (overview): shape=(3, 5490, 5490)\nLevel 2 (overview): shape=(3, 2745, 2745)\nLevel 3 (overview): shape=(3, 1373, 1373)\nLevel 4 (overview): shape=(3, 687, 687)\n\nWrote Zarr V3 store to data/TCI.zarr\n</pre> In\u00a0[6]: Copied! <pre>from geozarr_toolkit import detect_conventions, validate_group\n\n# Reopen and validate\nif USE_S3:\n    read_store = S3Store(bucket, prefix=prefix, region=\"us-west-2\", skip_signature=True)\n    zarr_store = ObjectStore(read_store)\nelse:\n    zarr_store = LocalStore(local_path)\n\nroot = zarr.open_group(zarr_store, mode=\"r\")\n\ndetected = detect_conventions(dict(root.attrs))\nprint(f\"Detected conventions: {detected}\")\n\nresults = validate_group(root)\nfor conv, errors in results.items():\n    status = \"PASS\" if not errors else \"FAIL\"\n    print(f\"  [{status}] {conv}\")\n    for err in errors:\n        print(f\"         {err}\")\n\nprint(f\"\\nStore tree:\")\nroot.tree()\n</pre> from geozarr_toolkit import detect_conventions, validate_group  # Reopen and validate if USE_S3:     read_store = S3Store(bucket, prefix=prefix, region=\"us-west-2\", skip_signature=True)     zarr_store = ObjectStore(read_store) else:     zarr_store = LocalStore(local_path)  root = zarr.open_group(zarr_store, mode=\"r\")  detected = detect_conventions(dict(root.attrs)) print(f\"Detected conventions: {detected}\")  results = validate_group(root) for conv, errors in results.items():     status = \"PASS\" if not errors else \"FAIL\"     print(f\"  [{status}] {conv}\")     for err in errors:         print(f\"         {err}\")  print(f\"\\nStore tree:\") root.tree() <pre>Detected conventions: ['spatial', 'proj', 'multiscales']\n  [PASS] spatial\n  [PASS] proj\n  [PASS] multiscales\n  [PASS] zarr_conventions\n\nStore tree:\n</pre> Out[6]: <pre>/\n\u251c\u2500\u2500 0 (3, 10980, 10980) uint8\n\u251c\u2500\u2500 1 (3, 5490, 5490) uint8\n\u251c\u2500\u2500 2 (3, 2745, 2745) uint8\n\u251c\u2500\u2500 3 (3, 1373, 1373) uint8\n\u2514\u2500\u2500 4 (3, 687, 687) uint8\n</pre>"},{"location":"examples/cog-to-zarr/#converting-a-cloud-optimized-geotiff-to-zarr","title":"Converting a Cloud-Optimized GeoTIFF to Zarr\u00b6","text":"<p>This notebook walks through a complete end-to-end workflow: opening a remote Cloud-Optimized GeoTIFF, extracting geospatial metadata, writing a multi-resolution Zarr V3 store with all three conventions (proj:, spatial:, multiscales), and validating the result.</p> <p>We use the Sentinel-2 L2A TCI (true-color) band from the async-geotiff example.</p> <p>Prerequisites: The proj: Convention | Composition</p>"},{"location":"examples/cog-to-zarr/#step-1-open-the-remote-cog","title":"Step 1: Open the remote COG\u00b6","text":"<p>We use async-geotiff to open the Cloud-Optimized GeoTIFF directly from S3. The GeoTIFF object exposes the geospatial properties we need \u2014 <code>crs</code>, <code>transform</code>, <code>bounds</code>, and <code>shape</code> \u2014 without reading any pixel data.</p>"},{"location":"examples/cog-to-zarr/#step-2-build-convention-metadata-from-the-cog","title":"Step 2: Build convention metadata from the COG\u00b6","text":"<p>The GeoTIFF's properties map directly to convention attributes. The COG also contains internal overviews (reduced-resolution copies) which map naturally to the multiscales convention \u2014 each overview becomes a scale level.</p> <ul> <li><code>geotiff.crs.to_epsg()</code> \u2192 <code>proj:code</code></li> <li><code>geotiff.transform</code> (Affine coefficients) \u2192 <code>spatial:transform</code></li> <li><code>geotiff.shape</code> \u2192 <code>spatial:shape</code></li> <li><code>geotiff.bounds</code> \u2192 <code>spatial:bbox</code></li> <li><code>geotiff.overviews</code> \u2192 <code>multiscales</code> layout</li> </ul>"},{"location":"examples/cog-to-zarr/#step-3-read-and-write-to-zarr-v3-with-multiscales","title":"Step 3: Read and write to Zarr V3 with multiscales\u00b6","text":"<p>We read the full-resolution image and each overview, writing them as separate child arrays in a Zarr V3 store. Set <code>USE_S3</code> above to control the output destination:</p> <ul> <li><code>USE_S3 = True</code>: writes to a remote S3 bucket via obstore's <code>S3Store</code></li> <li><code>USE_S3 = False</code>: writes to a local directory via Zarr's <code>LocalStore</code></li> </ul>"},{"location":"examples/cog-to-zarr/#step-4-validate-the-zarr-store","title":"Step 4: Validate the Zarr store\u00b6","text":"<p>We reopen the store and use <code>validate_group</code> to confirm the conventions are correctly applied.</p>"},{"location":"examples/cog-to-zarr/#summary","title":"Summary\u00b6","text":"<p>This notebook demonstrated the full workflow from COG to convention-compliant Zarr V3:</p> <ol> <li>Open a remote COG with async-geotiff (no pixel data read)</li> <li>Extract CRS, transform, bounds, and overview structure</li> <li>Map these properties to proj:, spatial:, and multiscales convention attributes</li> <li>Write the full image and all overview levels to a remote Zarr V3 store on S3</li> <li>Validate that the store conforms to all three conventions</li> </ol> <p>The same pattern applies to any georeferenced raster \u2014 the convention attributes are derived from standard geospatial properties that every GeoTIFF provides.</p>"},{"location":"examples/composition/","title":"Convention Composition","text":"In\u00a0[1]: Copied! <pre>import json\n\nfrom geozarr_toolkit import (\n    MultiscalesConventionMetadata,\n    ProjConventionMetadata,\n    SpatialConventionMetadata,\n    create_multiscales_layout,\n    create_proj_attrs,\n    create_spatial_attrs,\n    create_zarr_conventions,\n)\n</pre> import json  from geozarr_toolkit import (     MultiscalesConventionMetadata,     ProjConventionMetadata,     SpatialConventionMetadata,     create_multiscales_layout,     create_proj_attrs,     create_spatial_attrs,     create_zarr_conventions, ) In\u00a0[2]: Copied! <pre># Sentinel-2 TCI band: 10m resolution, 10980x10980 pixels\nattrs = create_proj_attrs(code=\"EPSG:32612\")\nattrs.update(\n    create_spatial_attrs(\n        dimensions=[\"Y\", \"X\"],\n        transform=[10.0, 0.0, 300000.0, 0.0, -10.0, 4100040.0],\n        shape=[10980, 10980],\n        bbox=[300000.0, 3990240.0, 409800.0, 4100040.0],\n    )\n)\nattrs[\"zarr_conventions\"] = create_zarr_conventions(\n    ProjConventionMetadata(),\n    SpatialConventionMetadata(),\n)\n\nprint(json.dumps(attrs, indent=2))\n</pre> # Sentinel-2 TCI band: 10m resolution, 10980x10980 pixels attrs = create_proj_attrs(code=\"EPSG:32612\") attrs.update(     create_spatial_attrs(         dimensions=[\"Y\", \"X\"],         transform=[10.0, 0.0, 300000.0, 0.0, -10.0, 4100040.0],         shape=[10980, 10980],         bbox=[300000.0, 3990240.0, 409800.0, 4100040.0],     ) ) attrs[\"zarr_conventions\"] = create_zarr_conventions(     ProjConventionMetadata(),     SpatialConventionMetadata(), )  print(json.dumps(attrs, indent=2)) <pre>{\n  \"proj:code\": \"EPSG:32612\",\n  \"spatial:dimensions\": [\n    \"Y\",\n    \"X\"\n  ],\n  \"spatial:bbox\": [\n    300000.0,\n    3990240.0,\n    409800.0,\n    4100040.0\n  ],\n  \"spatial:transform_type\": \"affine\",\n  \"spatial:transform\": [\n    10.0,\n    0.0,\n    300000.0,\n    0.0,\n    -10.0,\n    4100040.0\n  ],\n  \"spatial:shape\": [\n    10980,\n    10980\n  ],\n  \"spatial:registration\": \"pixel\",\n  \"zarr_conventions\": [\n    {\n      \"uuid\": \"f17cb550-5864-4468-aeb7-f3180cfb622f\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-experimental/geo-proj/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-experimental/geo-proj/blob/v1/README.md\",\n      \"name\": \"proj:\",\n      \"description\": \"Coordinate reference system information for geospatial data\"\n    },\n    {\n      \"uuid\": \"689b58e2-cf7b-45e0-9fff-9cfc0883d6b4\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-conventions/spatial/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-conventions/spatial/blob/v1/README.md\",\n      \"name\": \"spatial:\",\n      \"description\": \"Spatial coordinate and transformation information\"\n    }\n  ]\n}\n</pre> In\u00a0[3]: Copied! <pre># Sentinel-2 multi-resolution group: 10m, 20m, and 60m bands\n# CRS and bounding box are shared; shape and transform vary per resolution.\nattrs = create_proj_attrs(code=\"EPSG:32612\")\nattrs.update(\n    create_spatial_attrs(\n        dimensions=[\"Y\", \"X\"],\n        bbox=[300000.0, 3990240.0, 409800.0, 4100040.0],\n    )\n)\nattrs.update(\n    create_multiscales_layout(\n        [\n            {\n                \"asset\": \"r10m\",\n                \"transform\": {\"scale\": [1.0, 1.0], \"translation\": [0.0, 0.0]},\n            },\n            {\n                \"asset\": \"r20m\",\n                \"derived_from\": \"r10m\",\n                \"transform\": {\"scale\": [2.0, 2.0], \"translation\": [0.0, 0.0]},\n            },\n            {\n                \"asset\": \"r60m\",\n                \"derived_from\": \"r10m\",\n                \"transform\": {\"scale\": [6.0, 6.0], \"translation\": [0.0, 0.0]},\n            },\n        ]\n    )\n)\nattrs[\"zarr_conventions\"] = create_zarr_conventions(\n    MultiscalesConventionMetadata(),\n    ProjConventionMetadata(),\n    SpatialConventionMetadata(),\n)\n\nprint(json.dumps(attrs, indent=2))\n</pre> # Sentinel-2 multi-resolution group: 10m, 20m, and 60m bands # CRS and bounding box are shared; shape and transform vary per resolution. attrs = create_proj_attrs(code=\"EPSG:32612\") attrs.update(     create_spatial_attrs(         dimensions=[\"Y\", \"X\"],         bbox=[300000.0, 3990240.0, 409800.0, 4100040.0],     ) ) attrs.update(     create_multiscales_layout(         [             {                 \"asset\": \"r10m\",                 \"transform\": {\"scale\": [1.0, 1.0], \"translation\": [0.0, 0.0]},             },             {                 \"asset\": \"r20m\",                 \"derived_from\": \"r10m\",                 \"transform\": {\"scale\": [2.0, 2.0], \"translation\": [0.0, 0.0]},             },             {                 \"asset\": \"r60m\",                 \"derived_from\": \"r10m\",                 \"transform\": {\"scale\": [6.0, 6.0], \"translation\": [0.0, 0.0]},             },         ]     ) ) attrs[\"zarr_conventions\"] = create_zarr_conventions(     MultiscalesConventionMetadata(),     ProjConventionMetadata(),     SpatialConventionMetadata(), )  print(json.dumps(attrs, indent=2)) <pre>{\n  \"proj:code\": \"EPSG:32612\",\n  \"spatial:dimensions\": [\n    \"Y\",\n    \"X\"\n  ],\n  \"spatial:bbox\": [\n    300000.0,\n    3990240.0,\n    409800.0,\n    4100040.0\n  ],\n  \"spatial:transform_type\": \"affine\",\n  \"spatial:registration\": \"pixel\",\n  \"multiscales\": {\n    \"layout\": [\n      {\n        \"asset\": \"r10m\",\n        \"transform\": {\n          \"scale\": [\n            1.0,\n            1.0\n          ],\n          \"translation\": [\n            0.0,\n            0.0\n          ]\n        }\n      },\n      {\n        \"asset\": \"r20m\",\n        \"derived_from\": \"r10m\",\n        \"transform\": {\n          \"scale\": [\n            2.0,\n            2.0\n          ],\n          \"translation\": [\n            0.0,\n            0.0\n          ]\n        }\n      },\n      {\n        \"asset\": \"r60m\",\n        \"derived_from\": \"r10m\",\n        \"transform\": {\n          \"scale\": [\n            6.0,\n            6.0\n          ],\n          \"translation\": [\n            0.0,\n            0.0\n          ]\n        }\n      }\n    ]\n  },\n  \"zarr_conventions\": [\n    {\n      \"uuid\": \"d35379db-88df-4056-af3a-620245f8e347\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-conventions/multiscales/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-conventions/multiscales/blob/v1/README.md\",\n      \"name\": \"multiscales\",\n      \"description\": \"Multiscale layout of zarr datasets\"\n    },\n    {\n      \"uuid\": \"f17cb550-5864-4468-aeb7-f3180cfb622f\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-experimental/geo-proj/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-experimental/geo-proj/blob/v1/README.md\",\n      \"name\": \"proj:\",\n      \"description\": \"Coordinate reference system information for geospatial data\"\n    },\n    {\n      \"uuid\": \"689b58e2-cf7b-45e0-9fff-9cfc0883d6b4\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-conventions/spatial/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-conventions/spatial/blob/v1/README.md\",\n      \"name\": \"spatial:\",\n      \"description\": \"Spatial coordinate and transformation information\"\n    }\n  ]\n}\n</pre> <p>In this example, the 10 m level is the base (<code>r10m</code>). The 20 m level has <code>scale: [2.0, 2.0]</code> meaning each pixel covers 2x the area of the base, and 60 m has <code>scale: [6.0, 6.0]</code>. The actual geospatial coordinates are determined by each level's <code>spatial:transform</code>, not by the multiscales scale factors.</p>"},{"location":"examples/composition/#convention-composition","title":"Convention Composition\u00b6","text":"<p>The proj: convention focuses solely on CRS definitions. For complete georeferencing, it is composed with the spatial: convention (affine transforms, bounding boxes) and the multiscales convention (multi-resolution pyramids).</p> <p>This notebook demonstrates how these three conventions work together.</p> <p>Prerequisites: The proj: Convention</p>"},{"location":"examples/composition/#composition-with-the-spatial-convention","title":"Composition with the spatial: Convention\u00b6","text":"<p>The proj: convention focuses solely on CRS definitions. For complete georeferencing, it is typically composed with the spatial: convention, which defines how to transform between pixel coordinates and CRS coordinates.</p> Convention Responsibility <code>proj:</code> What coordinate system (CRS definition) <code>spatial:</code> How to transform (affine matrix, bounding box, dimensions) <p>For our Sentinel-2 scene, the TCI band has 10 m pixels with an affine transform of <code>Affine(10.0, 0.0, 300000.0, 0.0, -10.0, 4100040.0)</code> \u2014 matching the output shown in the async-geotiff example. The <code>spatial:transform</code> uses the same Rasterio/Affine coefficient ordering <code>[a, b, c, d, e, f]</code>:</p> <ul> <li><code>a</code> = 10.0: pixel width (10 m east per column)</li> <li><code>b</code> = 0.0: no row rotation</li> <li><code>c</code> = 300000.0: easting of the upper-left corner</li> <li><code>d</code> = 0.0: no column rotation</li> <li><code>e</code> = -10.0: pixel height (10 m south per row)</li> <li><code>f</code> = 4100040.0: northing of the upper-left corner</li> </ul>"},{"location":"examples/composition/#composition-with-multiscales","title":"Composition with Multiscales\u00b6","text":"<p>Sentinel-2 bands are acquired at three native resolutions \u2014 10 m, 20 m, and 60 m \u2014 making it a natural multi-resolution dataset. When the proj:, spatial:, and multiscales conventions are composed together:</p> <ul> <li><code>proj:code</code> is defined once at the group level and applies to all resolution levels</li> <li><code>spatial:dimensions</code> and <code>spatial:bbox</code> are shared across all levels (same geographic extent)</li> <li>Each resolution level has its own <code>spatial:shape</code> and <code>spatial:transform</code> reflecting its pixel size</li> <li>The multiscales <code>transform.scale</code> describes the resampling relationship between levels, not the geospatial coordinate transformation</li> </ul>"},{"location":"examples/composition/#convention-responsibilities","title":"Convention Responsibilities\u00b6","text":"<p>Each convention has a focused scope:</p> Convention Namespace Responsibility proj: <code>proj:</code> What coordinate system (CRS definition) spatial: <code>spatial:</code> How to transform (affine matrix, bbox, dimensions) multiscales <code>multiscales</code> Which resolution levels and their relationships <p>This separation means you can use proj: alone for CRS-only metadata, add spatial: when you need coordinate transforms, and layer on multiscales for pyramid structures \u2014 all without modifying the other conventions.</p>"},{"location":"examples/composition/#summary","title":"Summary\u00b6","text":"<ul> <li>proj: + spatial: provides complete georeferencing (CRS + pixel-to-coordinate transforms)</li> <li>proj: + spatial: + multiscales adds multi-resolution support</li> <li>proj: is defined once at the group level; spatial: properties like <code>shape</code> and <code>transform</code> vary per resolution level</li> <li>multiscales <code>transform.scale</code> describes resampling relationships, not geospatial coordinates</li> </ul> <p>Next: COG to Zarr for a real-world end-to-end example</p>"},{"location":"examples/inheritance/","title":"Group-to-Array Inheritance","text":"In\u00a0[1]: Copied! <pre>import json\n\nfrom geozarr_toolkit import (\n    ProjConventionMetadata,\n    SpatialConventionMetadata,\n    create_proj_attrs,\n    create_spatial_attrs,\n    create_zarr_conventions,\n)\n</pre> import json  from geozarr_toolkit import (     ProjConventionMetadata,     SpatialConventionMetadata,     create_proj_attrs,     create_spatial_attrs,     create_zarr_conventions, ) In\u00a0[2]: Copied! <pre># Group-level CRS applies to all direct child arrays\ngroup_attrs = create_proj_attrs(code=\"EPSG:32612\")\ngroup_attrs[\"zarr_conventions\"] = create_zarr_conventions(ProjConventionMetadata())\n\nprint(\"Group attributes (shared by all child arrays):\")\nprint(json.dumps(group_attrs, indent=2))\n\n# Visualize the inheritance hierarchy\nprint()\nprint(\"Sentinel-2 scene group/        &lt;- proj:code = EPSG:32612\")\nprint(\"  \u251c\u2500\u2500 TCI   (10m)              &lt;- inherits EPSG:32612\")\nprint(\"  \u251c\u2500\u2500 B02   (10m)              &lt;- inherits EPSG:32612\")\nprint(\"  \u251c\u2500\u2500 B05   (20m)              &lt;- inherits EPSG:32612\")\nprint(\"  \u2514\u2500\u2500 B01   (60m)              &lt;- inherits EPSG:32612\")\n</pre> # Group-level CRS applies to all direct child arrays group_attrs = create_proj_attrs(code=\"EPSG:32612\") group_attrs[\"zarr_conventions\"] = create_zarr_conventions(ProjConventionMetadata())  print(\"Group attributes (shared by all child arrays):\") print(json.dumps(group_attrs, indent=2))  # Visualize the inheritance hierarchy print() print(\"Sentinel-2 scene group/        &lt;- proj:code = EPSG:32612\") print(\"  \u251c\u2500\u2500 TCI   (10m)              &lt;- inherits EPSG:32612\") print(\"  \u251c\u2500\u2500 B02   (10m)              &lt;- inherits EPSG:32612\") print(\"  \u251c\u2500\u2500 B05   (20m)              &lt;- inherits EPSG:32612\") print(\"  \u2514\u2500\u2500 B01   (60m)              &lt;- inherits EPSG:32612\") <pre>Group attributes (shared by all child arrays):\n{\n  \"proj:code\": \"EPSG:32612\",\n  \"zarr_conventions\": [\n    {\n      \"uuid\": \"f17cb550-5864-4468-aeb7-f3180cfb622f\",\n      \"schema_url\": \"https://raw.githubusercontent.com/zarr-experimental/geo-proj/refs/tags/v1/schema.json\",\n      \"spec_url\": \"https://github.com/zarr-experimental/geo-proj/blob/v1/README.md\",\n      \"name\": \"proj:\",\n      \"description\": \"Coordinate reference system information for geospatial data\"\n    }\n  ]\n}\n\nSentinel-2 scene group/        &lt;- proj:code = EPSG:32612\n  \u251c\u2500\u2500 TCI   (10m)              &lt;- inherits EPSG:32612\n  \u251c\u2500\u2500 B02   (10m)              &lt;- inherits EPSG:32612\n  \u251c\u2500\u2500 B05   (20m)              &lt;- inherits EPSG:32612\n  \u2514\u2500\u2500 B01   (60m)              &lt;- inherits EPSG:32612\n</pre> In\u00a0[3]: Copied! <pre># Group-level spatial: properties shared by all bands\ngroup_spatial = create_spatial_attrs(\n    dimensions=[\"Y\", \"X\"],\n    bbox=[300000.0, 3990240.0, 409800.0, 4100040.0],\n)\nprint(\"Group spatial: attributes (shared):\")\nprint(json.dumps(group_spatial, indent=2))\n\n# Each band supplements with its own shape and transform\nprint()\nprint(\"Array-level supplements (per resolution):\")\ntci_attrs = create_spatial_attrs(\n    dimensions=[\"Y\", \"X\"],\n    transform=[10.0, 0.0, 300000.0, 0.0, -10.0, 4100040.0],\n    shape=[10980, 10980],\n)\nprint(\n    f\"  TCI (10m):  shape={tci_attrs['spatial:shape']}, transform a={tci_attrs['spatial:transform'][0]}\"\n)\n\nb05_attrs = create_spatial_attrs(\n    dimensions=[\"Y\", \"X\"],\n    transform=[20.0, 0.0, 300000.0, 0.0, -20.0, 4100040.0],\n    shape=[5490, 5490],\n)\nprint(\n    f\"  B05 (20m):  shape={b05_attrs['spatial:shape']}, transform a={b05_attrs['spatial:transform'][0]}\"\n)\n\nb01_attrs = create_spatial_attrs(\n    dimensions=[\"Y\", \"X\"],\n    transform=[60.0, 0.0, 300000.0, 0.0, -60.0, 4100040.0],\n    shape=[1830, 1830],\n)\nprint(\n    f\"  B01 (60m):  shape={b01_attrs['spatial:shape']}, transform a={b01_attrs['spatial:transform'][0]}\"\n)\n</pre> # Group-level spatial: properties shared by all bands group_spatial = create_spatial_attrs(     dimensions=[\"Y\", \"X\"],     bbox=[300000.0, 3990240.0, 409800.0, 4100040.0], ) print(\"Group spatial: attributes (shared):\") print(json.dumps(group_spatial, indent=2))  # Each band supplements with its own shape and transform print() print(\"Array-level supplements (per resolution):\") tci_attrs = create_spatial_attrs(     dimensions=[\"Y\", \"X\"],     transform=[10.0, 0.0, 300000.0, 0.0, -10.0, 4100040.0],     shape=[10980, 10980], ) print(     f\"  TCI (10m):  shape={tci_attrs['spatial:shape']}, transform a={tci_attrs['spatial:transform'][0]}\" )  b05_attrs = create_spatial_attrs(     dimensions=[\"Y\", \"X\"],     transform=[20.0, 0.0, 300000.0, 0.0, -20.0, 4100040.0],     shape=[5490, 5490], ) print(     f\"  B05 (20m):  shape={b05_attrs['spatial:shape']}, transform a={b05_attrs['spatial:transform'][0]}\" )  b01_attrs = create_spatial_attrs(     dimensions=[\"Y\", \"X\"],     transform=[60.0, 0.0, 300000.0, 0.0, -60.0, 4100040.0],     shape=[1830, 1830], ) print(     f\"  B01 (60m):  shape={b01_attrs['spatial:shape']}, transform a={b01_attrs['spatial:transform'][0]}\" ) <pre>Group spatial: attributes (shared):\n{\n  \"spatial:dimensions\": [\n    \"Y\",\n    \"X\"\n  ],\n  \"spatial:bbox\": [\n    300000.0,\n    3990240.0,\n    409800.0,\n    4100040.0\n  ],\n  \"spatial:transform_type\": \"affine\",\n  \"spatial:registration\": \"pixel\"\n}\n\nArray-level supplements (per resolution):\n  TCI (10m):  shape=[10980, 10980], transform a=10.0\n  B05 (20m):  shape=[5490, 5490], transform a=20.0\n  B01 (60m):  shape=[1830, 1830], transform a=60.0\n</pre> In\u00a0[4]: Copied! <pre># Example: a child array that overrides the group CRS\narray_attrs = create_proj_attrs(code=\"EPSG:4326\")\n\nprint(\"Group:  proj:code = EPSG:32612 (UTM zone 12N)\")\nprint(\"Array:  proj:code = EPSG:4326  (WGS 84 geographic)\")\nprint()\nprint(\"Array-level attributes:\")\nprint(json.dumps(array_attrs, indent=2))\n</pre> # Example: a child array that overrides the group CRS array_attrs = create_proj_attrs(code=\"EPSG:4326\")  print(\"Group:  proj:code = EPSG:32612 (UTM zone 12N)\") print(\"Array:  proj:code = EPSG:4326  (WGS 84 geographic)\") print() print(\"Array-level attributes:\") print(json.dumps(array_attrs, indent=2)) <pre>Group:  proj:code = EPSG:32612 (UTM zone 12N)\nArray:  proj:code = EPSG:4326  (WGS 84 geographic)\n\nArray-level attributes:\n{\n  \"proj:code\": \"EPSG:4326\"\n}\n</pre>"},{"location":"examples/inheritance/#group-to-array-inheritance","title":"Group-to-Array Inheritance\u00b6","text":"<p>The proj: and spatial: conventions support group-to-array inheritance: when metadata is defined at the group level, it applies to all direct child arrays. The multiscales convention does not support inheritance \u2014 it is group-level only.</p> <p>This notebook covers:</p> <ol> <li>How inheritance works for proj: and spatial:</li> <li>Array-level overrides</li> <li>Why multiscales is different</li> </ol> <p>Prerequisites: The proj: Convention</p>"},{"location":"examples/inheritance/#inheritance-model","title":"Inheritance Model\u00b6","text":"<p>The proj: and spatial: conventions share the same inheritance rules:</p> <ul> <li>Group-level definition: metadata defined at the group level applies to all direct child arrays</li> <li>Direct children only: inheritance does not cascade to grandchildren or deeper levels</li> <li>Array-level override: any child array can define its own attributes to override the inherited values</li> </ul> Convention Inherits? Override behavior proj: Yes Full replacement \u2014 array's <code>proj:</code> replaces group's entirely spatial: Yes Override or supplement \u2014 array can replace individual properties multiscales No Group-level only; each group defines its own pyramid independently <p>Sentinel-2 scenes are a natural fit for this pattern: all bands share the same UTM CRS and bounding box, so defining <code>proj:</code> and shared <code>spatial:</code> properties once at the group level avoids repeating identical metadata across every band.</p>"},{"location":"examples/inheritance/#proj-inheritance","title":"proj: Inheritance\u00b6","text":"<p>When <code>proj:</code> is defined at the group level, the CRS applies to all direct child arrays. This is useful when multiple arrays (bands, variables, time steps) share the same coordinate reference system.</p> <p>For a Sentinel-2 scene, the CRS (EPSG:32612) is the same for every band, so we define it once at the group level.</p>"},{"location":"examples/inheritance/#spatial-inheritance","title":"spatial: Inheritance\u00b6","text":"<p>The spatial: convention also inherits from group to direct children. Group-level properties like <code>spatial:dimensions</code> and <code>spatial:bbox</code> apply to all child arrays. However, unlike proj:, spatial: allows partial override \u2014 a child array can supplement or replace individual properties while inheriting the rest.</p> <p>This is particularly useful with multi-resolution data: the bounding box and dimension names are shared, but <code>spatial:shape</code> and <code>spatial:transform</code> vary per resolution level.</p>"},{"location":"examples/inheritance/#array-level-override-proj","title":"Array-Level Override (proj:)\u00b6","text":"<p>A child array can fully replace the inherited CRS by defining its own <code>proj:</code> attributes. The override is complete \u2014 the array's <code>proj:</code> entirely replaces the group's.</p>"},{"location":"examples/inheritance/#why-multiscales-does-not-inherit","title":"Why Multiscales Does Not Inherit\u00b6","text":"<p>The multiscales convention is fundamentally different: it describes the structure of a pyramid (which child arrays exist, their scale relationships), not a property of individual arrays. It can only be defined at the group level and does not propagate to child groups.</p> <p>Each multiscale group defines its own pyramid independently. If you have nested groups that each contain pyramids, each group carries its own <code>multiscales</code> metadata \u2014 there is no cascading.</p> <pre><code>root/                          &lt;- multiscales: layout for [0, 1, 2, 3, 4]\n\u251c\u2500\u2500 0  (10980x10980)           &lt;- no multiscales (it's an array, not a group)\n\u251c\u2500\u2500 1  (5490x5490)\n\u251c\u2500\u2500 subgroup/                  &lt;- would need its own multiscales if it's a pyramid\n\u2502   \u251c\u2500\u2500 0\n\u2502   \u2514\u2500\u2500 1\n...\n</code></pre>"},{"location":"examples/inheritance/#summary","title":"Summary\u00b6","text":"Convention Inherits? Scope Override proj: Yes Direct children only Full replacement spatial: Yes Direct children only Override or supplement multiscales No Group-level only N/A <p>Key rules:</p> <ul> <li>Inheritance is one level deep \u2014 direct children only, never grandchildren</li> <li>proj: override is all-or-nothing: the array's CRS fully replaces the group's</li> <li>spatial: allows partial override: a child can define <code>spatial:shape</code> and <code>spatial:transform</code> while inheriting <code>spatial:bbox</code> and <code>spatial:dimensions</code> from the group</li> <li>multiscales describes pyramid structure, not array properties, so inheritance doesn't apply</li> </ul> <p>Next: Composition | COG to Zarr</p>"},{"location":"examples/proj-convention/","title":"The proj: Convention","text":"In\u00a0[1]: Copied! <pre>import json\n\nfrom pyproj import CRS\n\n# The CRS for our Sentinel-2 scene\ncrs = CRS.from_epsg(32612)\nprint(crs)\n</pre> import json  from pyproj import CRS  # The CRS for our Sentinel-2 scene crs = CRS.from_epsg(32612) print(crs) <pre>EPSG:32612\n</pre> In\u00a0[2]: Copied! <pre>from geozarr_toolkit import create_proj_attrs\n\n# Our Sentinel-2 scene uses UTM zone 12N\nattrs = create_proj_attrs(code=\"EPSG:32612\")\nprint(json.dumps(attrs, indent=2))\n</pre> from geozarr_toolkit import create_proj_attrs  # Our Sentinel-2 scene uses UTM zone 12N attrs = create_proj_attrs(code=\"EPSG:32612\") print(json.dumps(attrs, indent=2)) <pre>{\n  \"proj:code\": \"EPSG:32612\"\n}\n</pre> In\u00a0[3]: Copied! <pre># The same UTM zone 12N CRS, expressed as WKT2\nwkt2_string = crs.to_wkt()\n\nattrs = create_proj_attrs(wkt2=wkt2_string)\nprint(json.dumps(attrs, indent=2))\n</pre> # The same UTM zone 12N CRS, expressed as WKT2 wkt2_string = crs.to_wkt()  attrs = create_proj_attrs(wkt2=wkt2_string) print(json.dumps(attrs, indent=2)) <pre>{\n  \"proj:wkt2\": \"PROJCRS[\\\"WGS 84 / UTM zone 12N\\\",BASEGEOGCRS[\\\"WGS 84\\\",ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],MEMBER[\\\"World Geodetic System 1984 (G2296)\\\"],ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,LENGTHUNIT[\\\"metre\\\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\\\"Greenwich\\\",0,ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],ID[\\\"EPSG\\\",4326]],CONVERSION[\\\"UTM zone 12N\\\",METHOD[\\\"Transverse Mercator\\\",ID[\\\"EPSG\\\",9807]],PARAMETER[\\\"Latitude of natural origin\\\",0,ANGLEUNIT[\\\"degree\\\",0.0174532925199433],ID[\\\"EPSG\\\",8801]],PARAMETER[\\\"Longitude of natural origin\\\",-111,ANGLEUNIT[\\\"degree\\\",0.0174532925199433],ID[\\\"EPSG\\\",8802]],PARAMETER[\\\"Scale factor at natural origin\\\",0.9996,SCALEUNIT[\\\"unity\\\",1],ID[\\\"EPSG\\\",8805]],PARAMETER[\\\"False easting\\\",500000,LENGTHUNIT[\\\"metre\\\",1],ID[\\\"EPSG\\\",8806]],PARAMETER[\\\"False northing\\\",0,LENGTHUNIT[\\\"metre\\\",1],ID[\\\"EPSG\\\",8807]]],CS[Cartesian,2],AXIS[\\\"(E)\\\",east,ORDER[1],LENGTHUNIT[\\\"metre\\\",1]],AXIS[\\\"(N)\\\",north,ORDER[2],LENGTHUNIT[\\\"metre\\\",1]],USAGE[SCOPE[\\\"Navigation and medium accuracy spatial referencing.\\\"],AREA[\\\"Between 114\\u00b0W and 108\\u00b0W, northern hemisphere between equator and 84\\u00b0N, onshore and offshore. Canada - Alberta; Northwest Territories (NWT); Nunavut; Saskatchewan. Mexico. United States (USA).\\\"],BBOX[0,-114,84,-108]],ID[\\\"EPSG\\\",32612]]\"\n}\n</pre> In\u00a0[4]: Copied! <pre># The same UTM zone 12N CRS, expressed as PROJJSON\nprojjson_obj = crs.to_json_dict()\n\nattrs = create_proj_attrs(projjson=projjson_obj)\nprint(json.dumps(attrs, indent=2))\n</pre> # The same UTM zone 12N CRS, expressed as PROJJSON projjson_obj = crs.to_json_dict()  attrs = create_proj_attrs(projjson=projjson_obj) print(json.dumps(attrs, indent=2)) <pre>{\n  \"proj:projjson\": {\n    \"$schema\": \"https://proj.org/schemas/v0.7/projjson.schema.json\",\n    \"type\": \"ProjectedCRS\",\n    \"name\": \"WGS 84 / UTM zone 12N\",\n    \"base_crs\": {\n      \"name\": \"WGS 84\",\n      \"datum_ensemble\": {\n        \"name\": \"World Geodetic System 1984 ensemble\",\n        \"members\": [\n          {\n            \"name\": \"World Geodetic System 1984 (Transit)\",\n            \"id\": {\n              \"authority\": \"EPSG\",\n              \"code\": 1166\n            }\n          },\n          {\n            \"name\": \"World Geodetic System 1984 (G730)\",\n            \"id\": {\n              \"authority\": \"EPSG\",\n              \"code\": 1152\n            }\n          },\n          {\n            \"name\": \"World Geodetic System 1984 (G873)\",\n            \"id\": {\n              \"authority\": \"EPSG\",\n              \"code\": 1153\n            }\n          },\n          {\n            \"name\": \"World Geodetic System 1984 (G1150)\",\n            \"id\": {\n              \"authority\": \"EPSG\",\n              \"code\": 1154\n            }\n          },\n          {\n            \"name\": \"World Geodetic System 1984 (G1674)\",\n            \"id\": {\n              \"authority\": \"EPSG\",\n              \"code\": 1155\n            }\n          },\n          {\n            \"name\": \"World Geodetic System 1984 (G1762)\",\n            \"id\": {\n              \"authority\": \"EPSG\",\n              \"code\": 1156\n            }\n          },\n          {\n            \"name\": \"World Geodetic System 1984 (G2139)\",\n            \"id\": {\n              \"authority\": \"EPSG\",\n              \"code\": 1309\n            }\n          },\n          {\n            \"name\": \"World Geodetic System 1984 (G2296)\",\n            \"id\": {\n              \"authority\": \"EPSG\",\n              \"code\": 1383\n            }\n          }\n        ],\n        \"ellipsoid\": {\n          \"name\": \"WGS 84\",\n          \"semi_major_axis\": 6378137,\n          \"inverse_flattening\": 298.257223563\n        },\n        \"accuracy\": \"2.0\",\n        \"id\": {\n          \"authority\": \"EPSG\",\n          \"code\": 6326\n        }\n      },\n      \"coordinate_system\": {\n        \"subtype\": \"ellipsoidal\",\n        \"axis\": [\n          {\n            \"name\": \"Geodetic latitude\",\n            \"abbreviation\": \"Lat\",\n            \"direction\": \"north\",\n            \"unit\": \"degree\"\n          },\n          {\n            \"name\": \"Geodetic longitude\",\n            \"abbreviation\": \"Lon\",\n            \"direction\": \"east\",\n            \"unit\": \"degree\"\n          }\n        ]\n      },\n      \"id\": {\n        \"authority\": \"EPSG\",\n        \"code\": 4326\n      }\n    },\n    \"conversion\": {\n      \"name\": \"UTM zone 12N\",\n      \"method\": {\n        \"name\": \"Transverse Mercator\",\n        \"id\": {\n          \"authority\": \"EPSG\",\n          \"code\": 9807\n        }\n      },\n      \"parameters\": [\n        {\n          \"name\": \"Latitude of natural origin\",\n          \"value\": 0,\n          \"unit\": \"degree\",\n          \"id\": {\n            \"authority\": \"EPSG\",\n            \"code\": 8801\n          }\n        },\n        {\n          \"name\": \"Longitude of natural origin\",\n          \"value\": -111,\n          \"unit\": \"degree\",\n          \"id\": {\n            \"authority\": \"EPSG\",\n            \"code\": 8802\n          }\n        },\n        {\n          \"name\": \"Scale factor at natural origin\",\n          \"value\": 0.9996,\n          \"unit\": \"unity\",\n          \"id\": {\n            \"authority\": \"EPSG\",\n            \"code\": 8805\n          }\n        },\n        {\n          \"name\": \"False easting\",\n          \"value\": 500000,\n          \"unit\": \"metre\",\n          \"id\": {\n            \"authority\": \"EPSG\",\n            \"code\": 8806\n          }\n        },\n        {\n          \"name\": \"False northing\",\n          \"value\": 0,\n          \"unit\": \"metre\",\n          \"id\": {\n            \"authority\": \"EPSG\",\n            \"code\": 8807\n          }\n        }\n      ]\n    },\n    \"coordinate_system\": {\n      \"subtype\": \"Cartesian\",\n      \"axis\": [\n        {\n          \"name\": \"Easting\",\n          \"abbreviation\": \"E\",\n          \"direction\": \"east\",\n          \"unit\": \"metre\"\n        },\n        {\n          \"name\": \"Northing\",\n          \"abbreviation\": \"N\",\n          \"direction\": \"north\",\n          \"unit\": \"metre\"\n        }\n      ]\n    },\n    \"scope\": \"Navigation and medium accuracy spatial referencing.\",\n    \"area\": \"Between 114\\u00b0W and 108\\u00b0W, northern hemisphere between equator and 84\\u00b0N, onshore and offshore. Canada - Alberta; Northwest Territories (NWT); Nunavut; Saskatchewan. Mexico. United States (USA).\",\n    \"bbox\": {\n      \"south_latitude\": 0,\n      \"west_longitude\": -114,\n      \"north_latitude\": 84,\n      \"east_longitude\": -108\n    },\n    \"id\": {\n      \"authority\": \"EPSG\",\n      \"code\": 32612\n    }\n  }\n}\n</pre> <p>All three methods describe the same CRS \u2014 the choice depends on your use case:</p> Method When to use <code>proj:code</code> A well-known authority code exists (most common) <code>proj:wkt2</code> Self-contained text representation needed, or no authority code exists <code>proj:projjson</code> JSON-native representation preferred, or detailed CRS structure needed In\u00a0[5]: Copied! <pre>from geozarr_toolkit import ProjConventionMetadata, create_zarr_conventions\n\nconventions = create_zarr_conventions(ProjConventionMetadata())\nprint(json.dumps(conventions, indent=2))\n</pre> from geozarr_toolkit import ProjConventionMetadata, create_zarr_conventions  conventions = create_zarr_conventions(ProjConventionMetadata()) print(json.dumps(conventions, indent=2)) <pre>[\n  {\n    \"uuid\": \"f17cb550-5864-4468-aeb7-f3180cfb622f\",\n    \"schema_url\": \"https://raw.githubusercontent.com/zarr-experimental/geo-proj/refs/tags/v1/schema.json\",\n    \"spec_url\": \"https://github.com/zarr-experimental/geo-proj/blob/v1/README.md\",\n    \"name\": \"proj:\",\n    \"description\": \"Coordinate reference system information for geospatial data\"\n  }\n]\n</pre> <p>The convention entry contains:</p> <ul> <li>uuid (<code>f17cb550-...</code>): Permanent identifier for the proj: convention</li> <li>schema_url: Link to the JSON Schema used for machine validation</li> <li>spec_url: Link to the human-readable specification</li> <li>name: The namespace prefix (<code>proj:</code>)</li> <li>description: Brief summary of the convention's purpose</li> </ul> In\u00a0[6]: Copied! <pre># Complete zarr.json metadata for the Sentinel-2 TCI group\nfull_attrs = create_proj_attrs(code=\"EPSG:32612\")\nfull_attrs[\"zarr_conventions\"] = create_zarr_conventions(ProjConventionMetadata())\n\nzarr_metadata = {\n    \"zarr_format\": 3,\n    \"node_type\": \"group\",\n    \"attributes\": full_attrs,\n}\n\nprint(json.dumps(zarr_metadata, indent=2))\n</pre> # Complete zarr.json metadata for the Sentinel-2 TCI group full_attrs = create_proj_attrs(code=\"EPSG:32612\") full_attrs[\"zarr_conventions\"] = create_zarr_conventions(ProjConventionMetadata())  zarr_metadata = {     \"zarr_format\": 3,     \"node_type\": \"group\",     \"attributes\": full_attrs, }  print(json.dumps(zarr_metadata, indent=2)) <pre>{\n  \"zarr_format\": 3,\n  \"node_type\": \"group\",\n  \"attributes\": {\n    \"proj:code\": \"EPSG:32612\",\n    \"zarr_conventions\": [\n      {\n        \"uuid\": \"f17cb550-5864-4468-aeb7-f3180cfb622f\",\n        \"schema_url\": \"https://raw.githubusercontent.com/zarr-experimental/geo-proj/refs/tags/v1/schema.json\",\n        \"spec_url\": \"https://github.com/zarr-experimental/geo-proj/blob/v1/README.md\",\n        \"name\": \"proj:\",\n        \"description\": \"Coordinate reference system information for geospatial data\"\n      }\n    ]\n  }\n}\n</pre> In\u00a0[7]: Copied! <pre>from geozarr_toolkit import validate_proj\n\n# Valid: our Sentinel-2 scene's CRS\nis_valid, errors = validate_proj({\"proj:code\": \"EPSG:32612\"})\nprint(f\"Valid: {is_valid}, Errors: {errors}\")\n</pre> from geozarr_toolkit import validate_proj  # Valid: our Sentinel-2 scene's CRS is_valid, errors = validate_proj({\"proj:code\": \"EPSG:32612\"}) print(f\"Valid: {is_valid}, Errors: {errors}\") <pre>Valid: True, Errors: []\n</pre> In\u00a0[8]: Copied! <pre># Invalid: no CRS encoding provided\nis_valid, errors = validate_proj({})\nprint(f\"Valid: {is_valid}\")\nfor error in errors:\n    print(f\"  {error}\")\n</pre> # Invalid: no CRS encoding provided is_valid, errors = validate_proj({}) print(f\"Valid: {is_valid}\") for error in errors:     print(f\"  {error}\") <pre>Valid: False\n  {'type': 'value_error', 'loc': (), 'msg': 'Value error, At least one of proj:code, proj:wkt2, or proj:projjson must be provided', 'input': {}, 'ctx': {'error': ValueError('At least one of proj:code, proj:wkt2, or proj:projjson must be provided')}, 'url': 'https://errors.pydantic.dev/2.12/v/value_error'}\n</pre> In\u00a0[9]: Copied! <pre># All three representations of the Sentinel-2 scene's CRS\nprint(\"proj:code\")\nprint(f\"  EPSG:{crs.to_epsg()}\")\nprint()\nprint(\"proj:wkt2 (truncated)\")\nprint(f\"  {crs.to_wkt()[:80]}...\")\nprint()\nprint(\"proj:projjson (summary)\")\npj = crs.to_json_dict()\nprint(f\"  type: {pj['type']}\")\nprint(f\"  name: {pj['name']}\")\nprint(f\"  keys: {list(pj.keys())}\")\n</pre> # All three representations of the Sentinel-2 scene's CRS print(\"proj:code\") print(f\"  EPSG:{crs.to_epsg()}\") print() print(\"proj:wkt2 (truncated)\") print(f\"  {crs.to_wkt()[:80]}...\") print() print(\"proj:projjson (summary)\") pj = crs.to_json_dict() print(f\"  type: {pj['type']}\") print(f\"  name: {pj['name']}\") print(f\"  keys: {list(pj.keys())}\") <pre>proj:code\n  EPSG:32612\n\nproj:wkt2 (truncated)\n  PROJCRS[\"WGS 84 / UTM zone 12N\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic Sy...\n\nproj:projjson (summary)\n  type: ProjectedCRS\n  name: WGS 84 / UTM zone 12N\n  keys: ['$schema', 'type', 'name', 'base_crs', 'conversion', 'coordinate_system', 'scope', 'area', 'bbox', 'id']\n</pre>"},{"location":"examples/proj-convention/#the-proj-convention","title":"The proj: Convention\u00b6","text":"<p>The proj: convention encodes Coordinate Reference System (CRS) information for geospatial data stored in Zarr format. It answers the question \"what coordinate system is this data in?\" using one of three standard encodings.</p> <p>This notebook covers:</p> <ol> <li>The three CRS encoding methods: EPSG code, WKT2, and PROJJSON</li> <li>Convention registration via <code>zarr_conventions</code></li> <li>Validation</li> <li>Converting between CRS formats with pyproj</li> </ol> <p>See also:</p> <ul> <li>Inheritance \u2014 how CRS metadata propagates from groups to arrays</li> <li>Composition \u2014 combining proj: with spatial: and multiscales</li> <li>COG to Zarr \u2014 end-to-end conversion of a Cloud-Optimized GeoTIFF</li> </ul>"},{"location":"examples/proj-convention/#example-dataset","title":"Example Dataset\u00b6","text":"<p>Throughout this notebook we use a Sentinel-2 L2A scene from the <code>sentinel-cogs</code> bucket on AWS as our running example (following the async-geotiff demo).</p> <p>The scene is tile 12/S/UF acquired on 2022-06-09. Its key geospatial properties are:</p> Property Value CRS EPSG:32612 (WGS 84 / UTM zone 12N) Pixel size 10 m (TCI band) Origin (300000.0, 4100040.0) Dimensions 10980 rows x 10980 columns Bounding box 300000.0, 3990240.0, 409800.0, 4100040.0 <p>Sentinel-2 is a good example because it has bands at three native resolutions (10 m, 20 m, 60 m) that all share the same CRS \u2014 a natural fit for group-level inheritance and multiscale composition.</p>"},{"location":"examples/proj-convention/#overview","title":"Overview\u00b6","text":"<p>The proj: convention defines three properties, all using the <code>proj:</code> namespace prefix:</p> Property Type Description <code>proj:code</code> string Authority:code identifier (e.g., <code>EPSG:4326</code>) <code>proj:wkt2</code> string WKT2 (ISO 19162) CRS representation <code>proj:projjson</code> object PROJJSON CRS representation <p>Exactly one of these must be provided. The convention can be applied to both Zarr groups and arrays.</p>"},{"location":"examples/proj-convention/#method-1-epsg-code","title":"Method 1: EPSG Code\u00b6","text":"<p>The simplest way to specify a CRS is with an authority:code identifier. The <code>proj:code</code> string follows the pattern <code>AUTHORITY:CODE</code> and must match <code>^[A-Z]+:[0-9]+$</code>.</p> <p>Known projection authorities include:</p> Authority Description EPSG European Petroleum Survey Group IAU International Astronomical Union (e.g., <code>IAU_2015:30100</code>) OGC Open Geospatial Consortium ESRI Esri spatial references <p>This is the preferred method when a well-known code exists for the CRS, because it's compact and unambiguous.</p>"},{"location":"examples/proj-convention/#method-2-wkt2","title":"Method 2: WKT2\u00b6","text":"<p>WKT2 (ISO 19162:2019) provides a full textual CRS representation. It is useful when:</p> <ul> <li>No valid authority code exists for the CRS</li> <li>You need the full CRS definition to be self-contained in the metadata</li> <li>The CRS uses custom parameters not captured by a registered code</li> </ul> <p>Here we use pyproj to obtain the WKT2 string for the same Sentinel-2 CRS.</p>"},{"location":"examples/proj-convention/#method-3-projjson","title":"Method 3: PROJJSON\u00b6","text":"<p>PROJJSON is a JSON encoding of CRS definitions following the PROJ specification. Since it's a native JSON object, it integrates naturally with Zarr's JSON-based metadata and can be validated against the PROJJSON schema.</p>"},{"location":"examples/proj-convention/#convention-registration","title":"Convention Registration\u00b6","text":"<p>Every Zarr convention must be registered in the <code>zarr_conventions</code> array in the node's attributes. This array identifies which conventions are in use and provides links to their schemas and specifications.</p> <p>A convention entry must include at least one of <code>uuid</code>, <code>schema_url</code>, or <code>spec_url</code> to be identifiable.</p>"},{"location":"examples/proj-convention/#putting-it-together","title":"Putting It Together\u00b6","text":"<p>Here's what the complete Zarr V3 metadata looks like for a Sentinel-2 group using the proj: convention. This is the structure that would appear in the group's <code>zarr.json</code> file.</p>"},{"location":"examples/proj-convention/#validation","title":"Validation\u00b6","text":"<p>The <code>validate_proj</code> helper checks that attributes conform to the convention. It returns a <code>(is_valid, errors)</code> tuple. The key rule is that exactly one of <code>proj:code</code>, <code>proj:wkt2</code>, or <code>proj:projjson</code> must be present.</p>"},{"location":"examples/proj-convention/#converting-between-crs-formats-with-pyproj","title":"Converting Between CRS Formats with pyproj\u00b6","text":"<p>In practice, pyproj makes it easy to start from any CRS representation and produce whichever format the proj: convention requires.</p>"},{"location":"examples/proj-convention/#summary","title":"Summary\u00b6","text":"<p>The proj: convention provides three methods for encoding CRS information in Zarr:</p> Method When to use <code>proj:code</code> A well-known authority code exists (most common) <code>proj:wkt2</code> Self-contained text representation needed <code>proj:projjson</code> JSON-native representation preferred <p>Each convention entry is registered in <code>zarr_conventions</code> with a UUID, schema URL, and spec URL.</p> <p>Next: Inheritance | Composition | COG to Zarr</p> <p>For the full specification, see the proj: convention README.</p>"}]}